# 947.移除最多的同行或同列石头
# n块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。
# 如果一块石头的同行或者同列上有其他石头存在，那么就可以移除这块石头。
# 给你一个长度为n 的数组stones ，其中stones[i] = [xi, yi]表示第i块石头的位置，返回可以移除的石子的最大数量。
# 示例1：
# 输入：stones = [[0, 0], [0, 1], [1, 0], [1, 2], [2, 1], [2, 2]]
# 输出：5
# 解释：一种移除5块石头的方法如下所示：
# 1.移除石头[2, 2] ，因为它和[2, 1]同行。
# 2.移除石头[2, 1] ，因为它和[0, 1]同列。
# 3.移除石头[1, 2] ，因为它和[1, 0]同行。
# 4.移除石头[1, 0] ，因为它和[0, 0]同列。
# 5.移除石头[0, 1] ，因为它和[0, 0]同行。
# 石头[0, 0]不能移除，因为它没有与另一块石头同行 / 列。
#
# 示例2：
# 输入：stones = [[0, 0], [0, 2], [1, 1], [2, 0], [2, 2]]
# 输出：3
# 解释：一种移除
# 3块石头的方法如下所示：
# 1.移除石头[2, 2] ，因为它和[2, 0]同行。
# 2.移除石头[2, 0] ，因为它和[0, 0]同列。
# 3.移除石头[0, 2] ，因为它和[0, 0]同行。
# 石头[0, 0]和[1, 1]不能移除，因为它们没有与另一块石头同行 / 列。
#
# 示例3：
# 输入：stones = [[0, 0]]
# 输出：0
# 解释：[0, 0]是平面上唯一一块石头，所以不可以移除它。

# 提示：
# 1 <= stones.length <= 1000
# 0 <= xi, yi <= 104
# 不会有两块石头放在同一个坐标点上


def removeStones(stones):  # 并查集还是没吃透，写得一坨屎，不明白评论区的为什么要加10000
    """
    :type stones: List[List[int]]
    :rtype: int
    """
    n = len(stones)
    if n <= 1:
        return 0
    f = [i for i in range(len(stones))]

    def find(x):
        if f[x] == x:
            return x
        f[x] = find(f[x])
        return f[x]

    def merge(i, j):
        y1, y2 = find(i), find(j)
        if y1 != y2:
            f[y2] = y1

    for i in range(n):
        for j in range(i + 1, n):
            if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:
                merge(i, j)
    res = 0
    for i in range(n):
        if f[i] == i:
            res += 1
    return n - res


stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
print(removeStones([[0,1],[1,0],[1,1]]))