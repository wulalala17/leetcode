# 989. 数组形式的整数加法
# 对于非负整数X而言，X的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果X = 1231，那么其数组形式为[1, 2, 3, 1]。
# 给定非负整数X的数组形式A，返回整数X + K的数组形式。

# 示例1：
# 输入：A = [1, 2, 0, 0], K = 34
# 输出：[1, 2, 3, 4]
# 解释：1200 + 34 = 1234
#
# 示例2：
# 输入：A = [2, 7, 4], K = 181
# 输出：[4, 5, 5]
# 解释：274 + 181 = 455
#
# 示例3：
# 输入：A = [2, 1, 5], K = 806
# 输出：[1, 0, 2, 1]
# 解释：215 + 806 = 1021
#
# 示例4：
# 输入：A = [9, 9, 9, 9, 9, 9, 9, 9, 9, 9], K = 1
# 输出：[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
# 解释：9999999999 + 1 = 10000000000
#
# 提示：
# 1 <= A.length <= 10000
# 0 <= A[i] <= 9
# 0 <= K <= 10000
# 如果A.length > 1，那么A[0] != 0

class Solution(object):
    def addToArrayForm(self, A, K):
        """
        :type A: List[int]
        :type K: int
        :rtype: List[int]
        """
        r = 0
        for a in A:
            r = r*10 + a
        res =  r + K
        ans = []
        while res >= 10:
            ans.insert(0, res%10)
            res = res // 10
        ans.insert(0, res%10)
        return ans
    # 参考评论区
    # 1，不可将A数组遍历得到sumA，与K做加法得到和，原因：A数组的长度可能很长，整数越界；
    # 2，我的做法：将K与A倒序的每个元素相加得到和，将和取模得到每个元素，插入到新数组中。
    #     res = []
    #     for i in range(len(A)-1,-1,-1):
    #         K += A[i]
    #         res.insert(0, K % 10)
    #         K = K // 10
    #     while K > 0:
    #         res.insert(0, K % 10)
    #         K = K /  10
    #     return res
