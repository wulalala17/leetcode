# 621.
# 任务调度器
#
# 给你一个用字符数组tasks表示的CPU需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在1
# 个单位时间内执行完。在任何一个单位时间，CPU可以完成一个任务，或者处于待命状态。然而，两个相同种类的任务之间必须有长度为整数n的冷却时间，因此至少有连续n个单位时间内
# CPU在执行不同的任务，或者在待命状态。
# 你需要计算完成所有任务所需要的最短时间
# 示例
# 1：
# 输入：tasks = ["A", "A", "A", "B", "B", "B"], n = 2
# 输出：8
# 解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
# 在本示例中，两个相同类型任务之间必须间隔长度为n=1的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。
# 示例
# 2：
# 输入：tasks = ["A", "A", "A", "B", "B", "B"], n = 0
# 输出：6
# 解释：在这种情况下，任何大小为
# 6
# 的排列都可以满足要求，因为n = 0
# ["A", "A", "A", "B", "B", "B"]
# ["A", "B", "A", "B", "A", "B"]
# ["B", "B", "B", "A", "A", "A"]
# ...
# 诸如此类
# 示例
# 3：
# 输入：tasks = ["A", "A", "A", "A", "A", "A", "B", "C", "D", "E", "F", "G"], n = 2
# 输出：16
# 解释：一种可能的解决方案是：
# A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A
# 提示：
# 1 <= task.length <= 104
# tasks[i]是大写英文字母n的取值范围为[0, 100]

# class Solution: 别人的牛逼题解
#     def leastInterval(self, tasks: List[str], n: int) -> int:
#         if n == 0:
#             return len(tasks)
#         count = [0 for _ in range(26)]
#         for t in tasks:
#             count[ord(t)-ord('A')] += 1
#         count.sort()
#         maxCount = 0
#         for i in range(25,-1,-1):
#             if count[i] != count[25]:
#                 break
#             maxCount += 1
#         return max((count[25]-1)*(n+1)+maxCount, len(tasks))

